/* esm.sh - esbuild bundle(cockatiel@3.0.0) deno production */
import __Process$ from "https://deno.land/std@0.170.0/node/process.ts";var d=class{constructor(t){this.interval=t}next(){return K(this.interval)}},K=e=>({duration:e,next(){return this}});var j=class{constructor(t){this.fn=t}next(t){return O(this.fn).next(t)}},O=(e,t,r=0)=>({duration:r,next(s){let i=e(s,t);return typeof i=="number"?O(e,t,i):O(e,i.state,i.delay)}});var W=(e=0,t)=>[Math.min(t.maxDelay,t.initialDelay*2**e),e+1],et=(e,t)=>{let[r,s]=W(e,t);return[Math.floor(Math.random()*r),s]},rt=(e,t)=>{let[r,s]=W(e,t);return[Math.floor((r+Math.random()*r)/2),s]};var Q=.7142857142857143,q=(e,t)=>{let[r,s]=e||[0,0],i=r+Math.random(),n=Math.pow(t.exponent,i)*Math.tanh(Math.sqrt(4*i)),a=Math.max(0,n-s);return[Math.min(a*Q*t.initialDelay,t.maxDelay),[r+1,n]]};var M={generator:q,maxDelay:3e4,exponent:2,initialDelay:128},D=class{constructor(t){this.options=t?{...M,...t}:M}next(){return H(this.options).next(void 0)}},H=(e,t,r=0,s=-1)=>({duration:r,next(){let[i,n]=e.generator(t,e);return H(e,n,i,s+1)}});var B=class{constructor(t){this.durations=t}next(){return G(this.durations,0)}},G=(e,t)=>({duration:e[t],next(){return t===e.length-1?this:G(e,t+1)}});var l=class extends Error{constructor(t="Operation cancelled"){super(t),this.message=t,this.isTaskCancelledError=!0}};var V={dispose:()=>{}},v;(function(e){e.once=(t,r)=>{let s=!1,i;return i=t(n=>{r(n),i?i.dispose():s=!0}),s?(i.dispose(),V):i},e.toPromise=(t,r)=>r?r.aborted?Promise.reject(new l):new Promise((s,i)=>{let n=b(r)(()=>{a.dispose(),i(new l)}),a=e.once(t,f=>{n.dispose(),s(f)})}):new Promise(s=>e.once(t,s))})(v||(v={}));var b=e=>{let t=new R;if(e.aborted)return t.emit(),t.addListener;let r=()=>{t.emit(),e.removeEventListener("abort",r)};return e.addEventListener("abort",r),t.addListener},u=class{constructor(){this.addListener=t=>this.addListenerInner(t)}get size(){return this.listeners?typeof this.listeners=="function"?1:this.listeners.length:0}emit(t){if(this.listeners)if(typeof this.listeners=="function")this.listeners(t);else for(let r of this.listeners)r(t)}addListenerInner(t){return this.listeners?typeof this.listeners=="function"?this.listeners=[this.listeners,t]:this.listeners.push(t):this.listeners=t,{dispose:()=>this.removeListener(t)}}removeListener(t){if(!this.listeners)return;if(typeof this.listeners=="function"){this.listeners===t&&(this.listeners=void 0);return}let r=this.listeners.indexOf(t);r!==-1&&(this.listeners.length===2?this.listeners=r===0?this.listeners[1]:this.listeners[0]:this.listeners=this.listeners.slice(0,r).concat(this.listeners.slice(r+1)))}};var R=class extends u{constructor(){super(...arguments),this.addListener=t=>this.lastValue?(t(this.lastValue.value),V):this.addListenerInner(t)}emit(t){this.lastValue={value:t},super.emit(t),this.listeners=void 0}};var p=new AbortController().signal,U=new AbortController;U.abort();var lt=U.signal,P=e=>{let t=new AbortController;return e&&(e.aborted&&t.abort(),b(e)(()=>t.abort())),t};var m=e=>{if("error"in e)throw e.error;return"success"in e?e.success:e.value},X=()=>{if(typeof performance<"u"){let e=performance.now();return()=>performance.now()-e}else{let e=__Process$.hrtime.bigint();return()=>Number(__Process$.hrtime.bigint()-e)/1e6}},c=class{constructor(t=()=>!1,r=()=>!1){this.errorFilter=t,this.resultFilter=r,this.successEmitter=new u,this.failureEmitter=new u,this.onSuccess=this.successEmitter.addListener,this.onFailure=this.failureEmitter.addListener}clone(){return new c(this.errorFilter,this.resultFilter)}async invoke(t,...r){let s=this.successEmitter.size||this.failureEmitter.size?X():null;try{let i=await t(...r);return this.resultFilter(i)?(s&&this.failureEmitter.emit({duration:s(),handled:!0,reason:{value:i}}),{value:i}):(s&&this.successEmitter.emit({duration:s()}),{success:i})}catch(i){let n=i,a=this.errorFilter(n);if(s&&this.failureEmitter.emit({duration:s(),handled:a,reason:{error:n}}),!a)throw n;return{error:n}}}};var x=class extends Error{constructor(t="Execution prevented because the circuit breaker is open"){super(t),this.isBrokenCircuitError=!0}};var F=class extends Error{constructor(t,r){super(`Bulkhead capacity exceeded (0/${t} execution slots, 0/${r} available)`),this.isBulkheadRejectedError=!0}};var S=class extends x{constructor(){super("Execution prevented because the circuit breaker is open"),this.isIsolatedCircuitError=!0}};var vt=e=>!!e&&e instanceof Error&&"isBrokenCircuitError"in e,bt=e=>!!e&&e instanceof Error&&"isBulkheadRejectedError"in e,yt=e=>!!e&&e instanceof Error&&"isBulkheadRejectedError"in e,Ft=e=>!!e&&e instanceof Error&&"isBulkheadRejectedError"in e;var o;(function(e){e[e.Closed=0]="Closed",e[e.Open=1]="Open",e[e.HalfOpen=2]="HalfOpen",e[e.Isolated=3]="Isolated"})(o||(o={}));var g=class{constructor(t,r){this.options=t,this.executor=r,this.breakEmitter=new u,this.resetEmitter=new u,this.halfOpenEmitter=new u,this.stateChangeEmitter=new u,this.innerState={value:o.Closed},this.onBreak=this.breakEmitter.addListener,this.onReset=this.resetEmitter.addListener,this.onHalfOpen=this.halfOpenEmitter.addListener,this.onStateChange=this.stateChangeEmitter.addListener,this.onSuccess=this.executor.onSuccess,this.onFailure=this.executor.onFailure}get state(){return this.innerState.value}get lastFailure(){return this.innerLastFailure}isolate(){this.innerState.value!==o.Isolated&&(this.innerState={value:o.Isolated,counters:0},this.breakEmitter.emit({isolated:!0}),this.stateChangeEmitter.emit(o.Isolated)),this.innerState.counters++;let t=!1;return{dispose:()=>{t||(t=!0,this.innerState.value===o.Isolated&&!--this.innerState.counters&&(this.innerState={value:o.Closed},this.resetEmitter.emit(),this.stateChangeEmitter.emit(o.Closed)))}}}async execute(t,r=p){let s=this.innerState;switch(s.value){case o.Closed:let i=await this.executor.invoke(t,{signal:r});return"success"in i?this.options.breaker.success(s.value):(this.innerLastFailure=i,this.options.breaker.failure(s.value)&&this.open(i)),m(i);case o.HalfOpen:if(await s.test.catch(()=>{}),this.state===o.Closed&&r.aborted)throw new l;return this.execute(t);case o.Open:if(Date.now()-s.openedAt<this.options.halfOpenAfter)throw new x;let n=this.halfOpen(t,r);return this.innerState={value:o.HalfOpen,test:n},this.stateChangeEmitter.emit(o.HalfOpen),n;case o.Isolated:throw new S;default:throw new Error(`Unexpected circuit state ${s}`)}}async halfOpen(t,r){this.halfOpenEmitter.emit();try{let s=await this.executor.invoke(t,{signal:r});return"success"in s?(this.options.breaker.success(o.HalfOpen),this.close()):(this.innerLastFailure=s,this.options.breaker.failure(o.HalfOpen),this.open(s)),m(s)}catch(s){throw this.close(),s}}open(t){this.state===o.Isolated||this.state===o.Open||(this.innerState={value:o.Open,openedAt:Date.now()},this.breakEmitter.emit(t),this.stateChangeEmitter.emit(o.Open))}close(){this.state===o.HalfOpen&&(this.innerState={value:o.Closed},this.resetEmitter.emit(),this.stateChangeEmitter.emit(o.Closed))}};var $=class{constructor({threshold:t,duration:r,minimumRps:s}){if(this.windows=[],this.currentWindow=0,this.currentFailures=0,this.currentSuccesses=0,t<=0||t>=1)throw new RangeError(`SamplingBreaker threshold should be between (0, 1), got ${t}`);this.threshold=t;let i=Math.max(5,Math.ceil(r/1e3));for(let n=0;n<i;n++)this.windows.push({startedAt:0,failures:0,successes:0});this.windowSize=Math.round(r/i),this.duration=this.windowSize*i,s?this.minimumRpms=s/1e3:this.minimumRpms=5/(t*1e3)}success(t){t===o.HalfOpen&&this.resetWindows(),this.push(!0)}failure(t){if(this.push(!1),t!==o.Closed)return!0;let r=this.currentSuccesses+this.currentFailures;return r<this.duration*this.minimumRpms?!1:this.currentFailures>this.threshold*r}resetWindows(){this.currentFailures=0,this.currentSuccesses=0;for(let t of this.windows)t.failures=0,t.successes=0,t.startedAt=0}rotateWindow(t){let r=(this.currentWindow+1)%this.windows.length;this.currentFailures-=this.windows[r].failures,this.currentSuccesses-=this.windows[r].successes;let s=this.windows[r]={failures:0,successes:0,startedAt:t};return this.currentWindow=r,s}push(t){let r=Date.now(),s=this.windows[this.currentWindow];r-s.startedAt>=this.windowSize&&(s=this.rotateWindow(r)),t?(s.successes++,this.currentSuccesses++):(s.failures++,this.currentFailures++)}};var z=class{constructor(t){this.threshold=t,this.count=0}success(){this.count=0}failure(){return++this.count>=this.threshold}};var J=()=>{let e,t,r=new Promise((s,i)=>{e=s,t=i});return{resolve:e,reject:t,promise:r}};var k=class{constructor(t,r){this.capacity=t,this.queueCapacity=r,this.active=0,this.queue=[],this.onRejectEmitter=new u,this.executor=new c,this.onSuccess=this.executor.onSuccess,this.onFailure=this.executor.onFailure,this.onReject=this.onRejectEmitter.addListener}get executionSlots(){return this.capacity-this.active}get queueSlots(){return this.queueCapacity-this.queue.length}async execute(t,r=p){if(r.aborted)throw new l;if(this.active<this.capacity){this.active++;try{return await t({signal:r})}finally{this.active--,this.dequeue()}}if(this.queue.length<this.queueCapacity){let{resolve:s,reject:i,promise:n}=J();return this.queue.push({signal:r,fn:t,resolve:s,reject:i}),n}throw this.onRejectEmitter.emit(),new F(this.capacity,this.queueCapacity)}dequeue(){let t=this.queue.shift();t&&Promise.resolve().then(()=>this.execute(t.fn,t.signal)).then(t.resolve).catch(t.reject)}};var C=class{constructor(t,r){this.executor=t,this.value=r,this.onSuccess=this.executor.onSuccess,this.onFailure=this.executor.onFailure}async execute(t,r=p){let s=await this.executor.invoke(t,{signal:r});return"success"in s?s.success:this.value()}};var A=class{constructor(){this.executor=new c,this.onSuccess=this.executor.onSuccess,this.onFailure=this.executor.onFailure}async execute(t,r=p){return m(await this.executor.invoke(t,{signal:r}))}};var Y=(e,t)=>new Promise(r=>{let s=setTimeout(r,e);t&&s.unref()}),w=class{constructor(t,r){this.options=t,this.executor=r,this.onGiveUpEmitter=new u,this.onRetryEmitter=new u,this.onSuccess=this.executor.onSuccess,this.onFailure=this.executor.onFailure,this.onRetry=this.onRetryEmitter.addListener,this.onGiveUp=this.onGiveUpEmitter.addListener}dangerouslyUnref(){return new w({...this.options,unref:!0},this.executor.clone())}async execute(t,r=p){let s=this.options.backoff||new d(0),i;for(let n=0;;n++){let a=await this.executor.invoke(t,{attempt:n,signal:r});if("success"in a)return a.success;if(!r.aborted&&n<this.options.maxAttempts){let f={attempt:n+1,signal:r,result:a};i=i?i.next(f):s.next(f);let I=i.duration,N=Y(I,!!this.options.unref);this.onRetryEmitter.emit({...a,delay:I}),await N;continue}if(this.onGiveUpEmitter.emit(a),"error"in a)throw a.error;return a.value}}};var T;(function(e){e.Cooperative="optimistic",e.Aggressive="aggressive"})(T||(T={}));var E=class{constructor(t,r,s=new c,i=!1){this.duration=t,this.strategy=r,this.executor=s,this.unref=i,this.timeoutEmitter=new u,this.onTimeout=this.timeoutEmitter.addListener,this.onFailure=this.executor.onFailure,this.onSuccess=this.executor.onSuccess}dangerouslyUnref(){return new E(this.duration,this.strategy,this.executor,!0)}async execute(t,r){let s=P(r),i=setTimeout(()=>s.abort(),this.duration);this.unref&&i.unref();let n={signal:s.signal},a=b(s.signal),f=a(()=>this.timeoutEmitter.emit());try{return this.strategy===T.Cooperative?m(await this.executor.invoke(t,n,s.signal)):await this.executor.invoke(async()=>Promise.race([Promise.resolve(t(n,s.signal)),v.toPromise(a).then(()=>{throw new l(`Operation timed out after ${this.duration}ms`)})])).then(m)}finally{f.dispose(),s.abort(),clearTimeout(i)}}};var L=(e,t)=>t?r=>r instanceof e&&t(r):r=>r instanceof e,Z=()=>!0,y=()=>!1,h=class{constructor(t){this.options=t}orType(t,r){let s=L(t,r);return new h({...this.options,errorFilter:i=>this.options.errorFilter(i)||s(i)})}orWhen(t){return new h({...this.options,errorFilter:r=>this.options.errorFilter(r)||t(r)})}orWhenResult(t){return new h({...this.options,resultFilter:r=>this.options.resultFilter(r)||t(r)})}orResultType(t,r){let s=L(t,r);return new h({...this.options,resultFilter:i=>this.options.resultFilter(i)||s(i)})}},fe=new A,me=new h({errorFilter:Z,resultFilter:y});function de(e,t){return new h({errorFilter:L(e,t),resultFilter:y})}function xe(e){return new h({errorFilter:e,resultFilter:y})}function we(e,t){return new h({errorFilter:y,resultFilter:L(e,t)})}function Ee(e){return new h({errorFilter:y,resultFilter:e})}function ve(e,t=0){return new k(e,t)}function be(e){return(t,r,s)=>{let i=s.value;if(typeof i!="function")throw new Error(`Can only decorate functions with @cockatiel, got ${typeof i}`);s.value=function(...n){let a=n[n.length-1]instanceof AbortSignal?n.pop():void 0;return e.execute(f=>i.apply(this,[...n,f]),a)}}}function ye(e,t){return new E(e,t)}function Fe(...e){return{_altReturn:void 0,onFailure:e[0].onFailure,onSuccess:e[0].onSuccess,wrapped:e,execute(t,r){let s=(i,n)=>n===e.length?t(i):e[n].execute(a=>s({...i,...a},n+1),i.signal);return Promise.resolve(s({signal:r},0))}}}function Se(e,t){return new w({backoff:t.backoff||new d(0),maxAttempts:t.maxAttempts??1/0},new c(e.options.errorFilter,e.options.resultFilter))}function ge(e,t){return new g(t,new c(e.options.errorFilter,e.options.resultFilter))}function ke(e,t){return new C(new c(e.options.errorFilter,e.options.resultFilter),typeof t=="function"?t:()=>t)}export{x as BrokenCircuitError,k as BulkheadPolicy,F as BulkheadRejectedError,g as CircuitBreakerPolicy,o as CircuitState,z as ConsecutiveBreaker,d as ConstantBackoff,j as DelegateBackoff,v as Event,u as EventEmitter,D as ExponentialBackoff,C as FallbackPolicy,S as IsolatedCircuitError,B as IterableBackoff,A as NoopPolicy,h as Policy,w as RetryPolicy,$ as SamplingBreaker,l as TaskCancelledError,E as TimeoutPolicy,T as TimeoutStrategy,ve as bulkhead,ge as circuitBreaker,q as decorrelatedJitterGenerator,ke as fallback,et as fullJitterGenerator,rt as halfJitterGenerator,me as handleAll,we as handleResultType,de as handleType,xe as handleWhen,Ee as handleWhenResult,vt as isBrokenCircuitError,bt as isBulkheadRejectedError,yt as isIsolatedCircuitError,Ft as isTaskCancelledError,W as noJitterGenerator,fe as noop,Se as retry,ye as timeout,be as usePolicy,Fe as wrap};
